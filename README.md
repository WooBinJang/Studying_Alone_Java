# <혼자 공부하는 자바 책 내용 정리!!!>

# 형 변환
- 자동 형 변환 : 큰 허용 범위 <- 작은 허용 범위
- 강제 형 변환 : 작은 허용 범위 <- 큰 허용 범위
- String 타입을 기본 타입(int , double ...)으로 형 변환 : Integer.parseInt() String -> int
      							 Double.parseDouble() String -> double 

# 논리타입 ( ^ ) 
- 배타적 논리합 : 하나가 true 또 다른 하나가 false 인 경우 결과가 ture 이다

# for문
- 조건식, 초기화식 등 생략이 가능하다.

# break문
- break문은 가장 가까운 반복문만 종료시킨다. 만약 바깥쪽 반복문 종료시 라벨을 붙이고 break 라벨; 을 사용해야한다.

# 참조타입
- String / 배열 / 열거 / 인터페이스
- 스택 영역에 값이 아닌 힙영역에 생긴 번지가 저장
- 참조 타입변수 간의 비교연산자(==,!=) 시 값이 아닌 같은 객체를 참조하는지 비교

# 메모리 영역
- 메소드 영역 : 클레스 코드들이 저장 정적필드 메소드 .class 클래스에 바이트코드들이 저장
- 힙영역 : 클래스로 부터 생성된 객체들이 저장
- JVM 스택 영역 : 메소드가 호출될 때마다 프레임이 추가되고 (변수) 메소드가 종료되면 프레임이 제거

# 배열의 초기값
- 숫자타입 (int , double ,long) : 0
- String타입 : NUll
- 논리타입(boolean) : False

# 다차원 배열
- int [][] arr = new int [2][3]  => 2행 3열 배열
- 계단형 다차원 배열  int [][] arr = new int[2][];
					 arr[0] = new int[2];
					 arr[1] = new int[3];`
- 값 목록을 활용한 다차원 배열 int [][] arr ={{1,2},{3,4}}; 


# 배열복사
- System.arraycopy(원본배열 , 인덱스(원본배열) , 대상배열 , 인데스(대상배열) , 몇개);

# 향상된 for문
- for (타입 변수 : 배열) { ... } 
- 변수의 배열요소를 대입 후 배열의 요소 만큼 반복하고 끝남	

# 열거 타입
- 데이터 중에서 한정된 값을 갖는 타입 ex) 요일, 계절 등

# 객체 
- 물리적으로 존재하거나 추상적으로 생각할 수 있는것 중에서 자신의 속성을 가지며 식별 가능한 것 
- 속성(필드) + 동작(메소드)로 구성

# 객체 간의 관계
- 집합 관계 : 부품과 완성품의 관계 ex)  자동차 <- 엔진, 타이어, 핸들
- 사용 관계 : 객체 간의 상호작용 ex) 사람 -> 자동차
- 상속 관계 : 상위 객체를 기반으로 하위 객체를 생성 ex) 자동차 -> 기계

# 클래스(class)
- 자바의 설계도 
- 클래스에는 객체를 생성하기 위한 메소드와 필드가 정의되어 있다.

# 인스턴스
- 클래스로부터 만들어진 객체

# 라이브러리
- 객체 생성 및 메소드 제공 역할

# 클레스 멤버
- 필드 : 객체의 데이터가 저장되는 곳 
- 생성자 : 객체 생성 시 초기화 역활 담당
- 메소드 : 객체의 동작에 해당하는 실행 블록

# 필드 사용
- 클래스 내부에서 필드 이름으로 읽고 변경
- 클래스 외부에서 클래스로부터 객체 생성한 뒤 필드 사용
- 필드 선언은 생성자나 메소드 내부에서는 선언 불가

# 타입의 초기값
- 정수 타입 (byte, short, int long) = 0
- char 타입 = \u0000 (빈 공백)
- float 타입 = 0.0F
- double 타입 = 0.0
- boolean 타입 = false
- 참조 타입 (배열, 클래스(String), 인터페이스) = null

# 생성자
- 클래스로부터 new 연산자로 객체를 생성할 때 호출되어 객체의 초기화를 담당
- 생성자는 생략 가능하다 (클래스 내부에서 바이트 코드에 자동 추가)
- 생성자의 매개 변수는 생략할 수도 있고 여러 개 선언할 수도 있음
- 생성자의 매개 변수가 선언 될 경우 생성자 호출 시 매개 변수 값을 입력해줘야 함.
- 필드와 매개 변수 이름이 완전히 동일한 경우 this. 필드로 표현

# 생성자 오버로딩
- 매개 변수 달리하는 생성자를 여러 개 선언

# 메소드
- 리턴값이 없을 수도 있음 void 타입 
- void문에서 return 문을 사용하여 메소드 실행을 종료
- 리턴값이 있는 경우 리턴 타입이 선언부에 명시
- 매개 변수의 개수를 모를 경우 : 배열 타입으로 선언
- 객체 내부의 메소드호출 시 리턴 값이 있을경우 리턴값이 담을 수 있는 변수가 있어야하나 void 타입일 경우 변수 없이 가능하다.

# 메소드 오버로딩
- 같은 이름의 메소드를 여러 개 선언
- 매개값을 다양하게 받아 처리할 수 있도로 하기위함
- 매개변수의 타입, 개수, 순서 같은 경우 매개변수 이름이 달라도 메소드 오버로딩이 아니다.

# 인스턴스 멤버
- new 연산자로 객체를 생성한 후 사용할 수 있는 필드와 메소드 

# 정적(static)멥버
- 클래스에 고정된 멥버로서 객체 생성하지 않고 사용 할 수 있는 필드와 메소드

# 인스턴스 멤버와 정적 멤버 선택 기준
- 객체마다 가를 수 있는 필드 값 -> 인스턴스 필드로 선언
- 객체마다 다를 필요가 없는 필드값 -> 정적 필드로 선언
- 메소드 블록에 인스턴스 필드 또는 인스턴스 메소드가 사용할 경우 -> 인스턴스 메소드로 선언
- 메소드의 매개변수로만 작성이 되었거나 static 필드로만 작성되어 있을 경우  -> 정적 메소드로 선언

# 정적 메소드(static) 선언 시 주의할 점
- 정적 메소드 선언 시 그 내부에 인스턴스 필드 및 메소드 사용 불가
- 정적 메소드 선언 시 그 객체 자신 참조인 this 키워드 사용 불가

# 싱글톤
- 전체 프로그램에서 단 하나의 객체만 만들도록 보장하는 코딩 기법
- new 연산자를 통해 호출하는 것을 불가하도록 private 접근 제한자 사용
 
# final 필드
- 초기값이 저장되면 최종값이 되어 프로그램 실행 도중 수정 불가
- 인스턴스 final 필드 : 객체에 한번 초기화된 데이터를 변경 불가로 만들 경우 ex) 주민번호
- final  타입 필드; // 객체마다 초기값이 다른 경우 생성자에서 초기화 
- 정적 final 필드 : 불변의 값인 상수를 만들 경우 ex) PI (관례적으로 모두 대문자로 작성)
- static final 타입 상수 =초기값;

# 패키지
- 클래스를 유일하게 만들어주는 식별자 역할
- 패키지의 물리적인 형태는 파일 시스템의 폴더
- 패키지 이름은 모두 소문자로 작성하는 것이 관례

# 접근 제한자
- 클래스와 인터페이스 및 이들이 가진 멤버의 접근 제한
- 접근 제한이 강화 : private > default > protected > public 
- private : 클래스 내부에서만 사용가능하며 외부에서는 사용할 수 없도록 함
- default : 같은 패키지에 소속된 클래스에서만 사용할 수 있도록 함
- protected : 같은 패키지 또는 자식 클래스에서 사용할 수 있도록 함
- public : 외부 클래스가 자유롭게 사용할 수 있도록 함

# 클래스 접근 제한
- 같은 패키지 내에서만 사용할 것인지 다른 패키지 내에서도 사용할 수 있도록 할 것인지 결정 
- default 같은 패키지에서만 사용 가능 / public 다른 패키지에서도 사용 가능

# Getter 메소드 
- 외부로 필드값을 전달하는 것이 목적
- 필드값을 가공해서 외부로 전달할 수도 있음  ex) 필드값인 마일을 km단위로 환산 후 외부로 리턴

# Setter 메소드 
- 외부의 값을 받아 필드의 값을 변경하는 것을 목적
- 매개값 검증하여 유효한 값만 필드로 저장 할 수 있음 ex) 스피드는 음수일 수가 없으므로  if 문을 이용하여 값을 변경

# 상속
- 중복되는 코드를 줄임
- 부모 클래스의 한번의 수정으로 유지보수 시간이 줄임
- extends 뒤에 부모 클래스 기술
- 자식 클래스 선언 시 부모 클래스 선택
- 여러 개의 부모 클래스 상속할 수 없음
- 부모 클래스에서 private접근 제한 갖는 필드와 메소드는 상속 대상에서 제외
- 다른 패키지에 존재할 경우 defult 접근 제한된 필드와 메소드는 제외
- 자식 객체 생성할 때 부모 객체가 먼저 생성되고 그 다음 자식 객체가 생성됨
- 부모 클래스에 생성자에 매개 변수가 없다면 자식 클래스에 생성자에 super() 가 자동 생성 됨
- 부모 클래스에 생성자에 매개변수가 있다면 그에 맞는 자식 개체에서 매개 변수를 명시 해주어야만 함

# 메소드 재정의(오버라이딩 Overriding)
- 부모 클래스이 메소드가 자식 클래스에서 사용하기에 부적합할 경우 자식 클래스에서 수정하여 사용
- 메소드가 재정의될 경우 부모 객체 메소드가 숨겨지며, 자식 객체에서 메소드 호출하면 재정의된 자식 메소드가 호출됨
- 타입 , 이름이 다르면 재정의가 되지 않는다.
- 더 넓은 범위의 접근 제한 재정의 할 수 있다 ex) default -> public 

# @override
- 컴파일 과정(실행과정 X)에서 오버라이딩이 제대로 되었는지 확인 해준다. 

# final
- 부모 클래스에 메소드 앞에 fianl 있을 경우 재정의 불가
- 클래스 앞에 final 있는 경우 부모 클래스로 상속 받을수 없음

# 다형성
- 사용 방법은 동일하지만 다양한 객체 활용해 여러 실행결과가 나오도록 하는 성질
- 메소드가 재정의와 타입변환 으로 구현

# 자동 타입 변환(promotion)
- 프로그램 실행 도중 자동으로 타입 변환이 일어나는 것
- 부모타입 변수 = 자식타입
- 바로 위 부모가 아니더라도 상속 계층애서 상위 타입인 경우 자동 타입 변환 일어날 수 있음
- 메소드가 자식 클래스에서 재정의될 경우 자식 클래수의 메소드가 대신 호출 

# 강제 타입 변환(casting)
- 부모 타입을 자식 타입으로 변환
- 자식타입 변수 = (자식타입) 부모타입;
- 조건: 자식 타입이 부모 타입으로 자동 타입 변환한 후 다시 반대로 변환할 떄 사용

# instanceof 연산자
- 어떤 객체가 어느 클래스의 인스턴스인지 확인
- boolean result = 좌항 (객체) instanceof 우항 (타입)

# 추상 클래스
- 실체 크래스(객체 생성용 클래스)들의 공통적인 특성(필드,메소드)을 추출하여 선언한 것
- 추상 클래스와 실체 클래스는 부모,자식 클래스로서 상속 관계를 가짐
- 실제 클래스에 반드시 존재해야할 필드와 메소드의 선언(실체 클래스의 설계 규격 - 객체 생성용이 아님)
-실체 클래스에는 공통된 내용은 빠르게 물려받고, 다른 점만 선언하면 되므로 시간 절약
- abstract 키워드 선언
- new 연산자로 개체 생성 불가

# 추상 메소드
- 메소드 선언만 통일하고 실행 내용은 실체 클래스마다 달라야 하는 경우
- abstract 키워드로 선언되고 중괄호가 없는 메소드
- 하위 클래스는 반드시 재정의해서 실행 내용을 채워야 함
- 자식 클래스에서 다시 메소드를 재정의 해야하는 메소드

# 인터페이스(interface)
- 객체의 사용 방법을 정의한 타입
- 다양한 객체를 동일한 사용 방법으로 이용할 수 있다
- 다형성을 구현할 수 있다
- 인터페이스는 객체로 생성할 수 없으므로 생성자를 가질 수 없다. new 연산자로 객체 생성 불가
- 인터페이스 같은 경우 default 값이 public 타입이다

# 상수 필드 선언
- 인터페이스 필드에서 상수 필드만 선언이 가능하다.
- public static final 생략이 가능하다.

# 추상 메소드 선언
- 인터페이스 메소드에서 추상 메소드만 가능하다.
- abstract 생략이 가능하다.

# 구현 클래스
- 인터페이스에서 정의된 추상 메소드를 재정의해서 실행내용을 가지고 있는 클래스
- 클래스 선언부에 implements 키워드 추가하고 인터페이스 이름 명시

# 인터페이스의 자동 타입 변환
- 구현 객체와 자식 객체는 인터페이스 타입으로 자동 타입 변환 된다.
- 인터페이스 변수 = 구현 객체; => 자동 타입 변환

# 인터페이스의 강제 타입 변환
- 구현 객체가 인터페이스 타입으로 자동 변환하면 인터페이스에 선언된 메소드만 사용 가능
- 구현클래스 변수 = (구현클래스) 인터페이스변수;

# 인터페이스 상속
- 인터페이스는 다중 상속이 가능하다.

# 중첩 클래스
- 클래스 내부에 선언한 클래스
- 맴버 클래스(인스턴스 멤버 클래스 /정적 멤버 클래스)와 로컬 클래스로 나누어 진다.

# 멤버 클래스
- 인스턴스 멤버 클래스 : 상위 클래스 생성 없이는 생성, 메소드 호출, 필드 값 대입이 불가  정적 필드나 메소드 선언이 불가
-인스턴스 맴버 클래스 => 상위 객체가 있어야만 사용 가능!! = >상위 객체의 필드와 메소드가 정적이든 인스턴스이든 상관없음
- 정적 멤버 클래스 : 상위 클래스 없이 이름만으로 접근하여 생성, 메소드 호출 필드 값 대입이 가능함 (static)
- 정적 멤버 클래스 => 상위 객체가 없이도 사용 가능!! => >상위 객체의 인스턴스 필드 ,인스턴스 메소드 사용 불가 

# 로컬 클래스
- 생성자 또는 메소드 내에서 선언된 클래스
- 접근 제한자 및 static 붙일 수 없음.
- 로컬 클래스에서 매개 변수나 로컬 변수는 final 특성이 부여 됨 final 생략 가능

# 중첩 클래스 객체 참조
- this.은 현재 객체 내부의 필드를 참조한다
- 바깥 필드나 메소드를 참조 하기 위해서 this. 앞에 객체 이름을 써준다

# 중첩 인터페이스
- 클래스 내부에 선언한 인터페이스 

# 익명 자식 객체
- 이름이 없는 객체
- 어떤 클래스를 상속하거나 인터페이스를 구현하여야 익명 객체 생성 가능
- 부모클래스 변수 = new 부모클래스() {...}; 
- 자식 클래스가 재상용되지 않고 오로지 특정 위치에서 사용되는 경우 편리
- 필드 선언할 때 초기값으로 익명 자식 객체 생성
- 메소드 내에서 로컬 변수 선언 시 초기값으로 익명 객체 생성
- 메소드의 매개변수안에 부모타입의 매개변수를 호출 할때 익명 객체 생성

# 익명 구현 객체
- 구현 객체 클래스가 재사용되지 않고 오로지 특정 위치에서 사용되는 편리
- 필드 선언 시 초기값으로 익명 구현 객체 생성
- 메소드 내에서 로컬 변수 선언 시 초기값으로 익명 구현 객체 생성
- 매개 변수의 매개값이 익명 구현 객체 생성

# 익명 객체의 로컬 변수 사용
- 메소드가 종료되어도 익명 객체가 계속 실행 상태로 존재할 수 있음
- 컴파일 시 익명 객체에서 사용하는 매개 변수나 로컬 변수는 final 특성을 가짐(값 변셩 불가)

# 예외
- 사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 인해 발생하는 프로그램 오류
- 예외 처리 프로그램 통해 정상 실행상태 유지 가능
- 예외 발생 가능성이 높은 코드를 컴파일할 때 컴파일러는 예외 처리 유무를 확인

# 일반 예외
- 컴파일러 체크 예외
- 자바 소스 컴파일 과정에서 해당 예외 처리 코드 있는지 검사하게 됨

# 실행 예외
- 컴파일러 NULL 체크 예외
- 실행 시 예측할 수 없이 갑자기 발생하기에 컴파일 과정에서 예외처리코드 검사하지 않음
- 실행 예외는 개발자의 경험에 의해서 예외 처리 코드 작성해야 함

# NullPointerException
- 가장 빈번하게 발생하는 실행 예외
- 객체 참조가 없는 상태의 참조 변수로 객체 접근 연산자 도트를 사용할 경우 발생

# ArrayIndexOutOfBoundsException
- 배열에서 인덱스 범위를 초과할 경우

# NumberFormatException
- 문자열을 숫자로 변환하는 경우

# ClassCastException
- 상위 및 하위 클래스 그리고 구현 클래스와 인터페이스 간 타입 변환 가능하나 이와 같은 관계가 아닌 경우 발생

# 예외 처리 코드
- 자바 컴파일러는 일반 예외를 발생시키는 코드를 발견할 경우 예외 처리 코드를 강제로 요구
- 실행 예외는 컴파일러가 체크하지 않으므로 개발자가 경험으로 예외처리 코드 작성

# try-catch-finally 블록
- 생성자 및 메소드 내부에서 작성되어 일반예외와 실행예외가 발생할 경우 예외 처리 가능하게 함	
- try 문에 예외가 발생 시 발생 위치 아래 코드는 읽지 않고 catch문으로 넘어간다
- finally문은 예외가 발생 여부와 관계없이 항상 실행 
- finally문이 필요없다면 생략이 가능

# throws 키워드
- 메소드에서 처리하지 않은 예외를 호출한 곳으로 넘기는 역활
- 메소드를 호출한 곳에서 다양한 방식으로 처리할 수 있도록 함
- throw 키워드 뒤에는 떠넘길 예외 클래스를 쉼표로 구분하여 나열

# 자바 API
- 프로그램 개발에 자주 사용되는 자바에서 제공하는 클래스 및 인터페이스 모음
- http://docs.oracle.com/en.java.javase/index.html

# java.lang
- 자바 프로그램의 기본적인 클래스를 담은 패키지
- java.lang 패키지의 클래스와 인터페이스는 import 없이 사용할 수 있다.

# Object 클래스
- 모든 클래스는 Object 클래스의 자식이거나 자손 클래스
- 객체 비교 (equals()) => equals() 메소드의 매개 타입은 Object로 모든 객체가 매개값으로 대입 가능
- 객체 해시코드(hashCode()) => 객체를 식별하는 하나의 정수값 , Object 클래스의 객체 해시모드 메소드는 객체 메모리 번지 이용하여 만듬 (객체마다 다른 값)  
- 객체 문자 정보(toString()) => Object 클래스의 toString() 메소드는 객체의 문자 정보 리턴

# System 클래스
- System 클래스의 모든 필드와 메소드는 정적(static) 필드 및 정적 메소드로 구성
- 프로그램 종료(exit()) => JVM 강제 종료, 메소드가 지정하는 int 매개값을 종료 상태값이라 함
- 현재 시각 읽기(correntTimeMillis(),nanoTimr()) long 타입 값 리턴

# Class 클래스
- 자바는 클래스와 인터페이스의 메타 데이터를 Class 클래스로 관리
- Class 객체는 파일 경로 정보를 가지고 있어 이 경로를 활용하여 다른 리소스 파일의 경로를 얻을 수 있음

# Class 객체 얻기
- getClass()  객체로부터 얻는 방법
- Class 변수명 = 클래스이름.class / Class 변수명 = Class.forName("패키지... 클래스이름") 클래스로부터 얻는 방법

# String 클래스
- 문자 추출(chatAt()) 매개값으로 주어진 인덱스의 문자를 리턴
- 문자열 비교(equals()) 문자열을 비교(번지 비교x)
- 바이트 배열로 변혼(getBytes())
- 문자열 찾기(indexOf()) 매개값으로 주언진 문자열이 시작되는 인덱스 리턴. 찾는 문자열이 없을 경우 -1를 리턴 
- 문자열 길이(length()) 문자열의 길이를 리턴
- 문자열 대치(replace()) 첫 번째 매개값인 문자열을 찾아 두 번째 매개값인 문자열로 대치한 새로운 문자열 생성 및 리턴
- 문자열 잘라내기(substring())  주어진 인덱스가 하나일 경우  주어진 인데스 부터 끝까지 문자열을 추출하고 인덱스가 두개이면 시작과 끝 인덱스 사이의 문자열을 추출한다.
- 알파벳 소,대문자 변경(toLowerCase(),toUpperCase()) 원본 문자열을 전부 대,소문자로 변경한다.
- 문자열 앞뒤 공백 잘라내기(trim()) 문자열의 앞뒤 공백 제거한 새로운 문자열 생성 및 리턴
- 문자열 변환(value()) 기본 타입의 값을 문자열로 변환

# Wrapper 클래스
- 기본 타입의 값을 내부의 두고 포장
- 포장하고 있는 기본 타입 값은 외부에서 변경할 수 없음
- int -> Integer / char -> Character
- 그외 나머지 기본 타입은 앞글자를 대문자로 표현한다 ex) double -> Double
- 포장 값 비교 시 ( ==,!= ) 말고 .equals()로 비교해야 한다.

# 박싱(Boxing)
- 기본 타입의 값을 포장 객체로 만드는 과정
- 생성자를 이용하여 생성 가능
- 생성자를 이용하지 않고 각 포장 클래스마다 가진 정적 vauleOf() 메소드로 생성 가능
- 자동 박싱 :포장 클래스 타입의 기본값이 대입될 경우 자동 박싱 발생

# 언박싱(UnBoxing)
- 포장 객체에서 기본 타입의 값을 얻어내는 과정
- 기본 타입 이름 +  Value() 메소드 호출하여 언박싱 가능
- 기본 타입에 포장 객체가 대입되는 경우 및 연산에서 자동 언박싱 발생
- 객체와 상수와 연산 할 수 없으나 자동 언박싱이 되어 연산이 가능하다.

# 문자열을 기본 타입 값으로 변환
- 포장 클래스로 문자열을 기본 타입으로 값으로 변환
- 기본 타입 클래스.parse+기본 타입 이름

# Math 클래스
- 수학 계산에 사용
- Math.abs() : 절대값
- Math.ceil() : 올림
- Math.floor() : 버림
- Math.max() : 최대값
- Math.min() : 최소값
- Math.random() : 랜덤값 0.0이상 1.0미만 범위에 속하는 하나의 double 타입 값 리턴
- Math.rint() : 가까운 정수의 실수값 (실수 타입만 가능)
- Math.round() : 반올림 (정수, 실수 타입 둘다 가능)

# java.util
- 날짜 정보를 제공하느 유요한 API를 제공하고 있다

# Date 클래스 
- 날짜를 표현하는 클래스, new 연산자로 생성 가능
- SimpleDateFormat 으로 패턴 설정 가능

# Calendar 클래스
- 달력을 표현한 클래스, 추상 클래스이므로 new 연산자로 생성 불가
- getInstance() 메소드 이용해서 Calendar 객체 생성 가능
- MONTH는 0~11 까지 리턴하므로 +1를 해주어야 한다

